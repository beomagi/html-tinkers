<!DOCTYPE HTML>
<html>
  <style>
    html, body {
      width:  100%;
      height: 100%;
      margin: 0px;
      border: 0px;
      padding: 0px;
      overflow: hidden;
      font-size: 0.9em;
      font-family: 'Courier New', 'consolas', monospace;
      cursor: pointer;
    }
    #details_main {
      width:  33%;
      margin: 0px;
      border: 0px;
      padding: 0px;
    }
    .cfgent {
      width:  100%;
      overflow: hidden;
      height: 5%;
      float: left;
      display: block;
    }
    .cfgent:hover{
      background-color: #555000;
    }
    .slideval {
      float: right;
      overflow: hidden;
      width: 15%;
    }
    .slider {
      width: 30%;
      float: right;
      background: #000000;
      color:#ffffff;
      height:0.5em;
      -webkit-appearance: none !important;
      outline: none;
    }
    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      background: #ffffff;
      height: 0.5em;
      width: 0.5em;
      margin-top: 0.25em;
      border-radius: 25%;
    }    
    .slider::-moz-range-thumb {
      background: #ffffff;
      height: 0.5em;
      width: 0.5em;
      margin-top: 0.25em;
      border-radius: 25%;
    }    
    .slider:hover {
      background: #0000ff;
    }    
  </style>
  <script language="javascript">
    var ctx=null;
    var inittime=Date.now();
    var maxwidth=0;
    var maxheight=0;
    var midwidth=0;
    var midheight=0;
    var squarescaler=0;
    var counter=0;
    var move=0;
    var direction=0.001;
    var mousePos={"x":0,"y":0};
    var paused=false;
    //info div
    var infodiv=null;
    var infodiv_drag=null;
    var infodiv_info=null;
    var infodiv_infopersonal=null;
    var statuswindowposX = 0, statuswindowposY = 0;
    var controlpanelcreated=false;
    //cities
    var cities=[];
    var phase=0;
    var cityincity=false;
    var cityarranging=true;
    var movementrate=0;    
    //people
    var peoplegenerated=false;
    var peoplearranging=false;
    var peopleA=[];
    var peopleB=[];
    var statA={};
    var statB={};
    var Hospitalmax=5; //maximum unmber of people at hospital
    var Hospitaltransmissionreduction=0.05;//reduce spread if at hospital
    var personundermouse={"n":-1,"ab":-1};
    var followingperson=Object.assign({},personundermouse)
    var persondetails="";
    //time
    var timer=0;
    //disease
    var diseases=[];
    var daymultiplier=100;
    var initinfection=false;
    var initinfectcount=0;
    var vaccineavgdelay=10;//10 day delay average for people to get vaccinated.
    var vaccineinterrupt=20;//must wait this long after being infected to get vaccine
    var vaccinekickin=0;//not implemented. Assuming vaccine delay can take this into account
    var midptstretch=0.001;//used to stretch the curve to get definite min/max values instead of 0 and inf
    var curvetune=0.1; //lower numbers cluster distribution about the average
    var dovaccinations=false;
    var dotravelrestriction=false;
    var travelrestrictiveness=0.75;
    var domasks=false;
    var vaccinelikeliness=0.7;
    var masklikeliness=0.75;

    //takes rgb and converts to single int color, then to hex
    function rgbToHex(r, g, b) { //thanks stackoverflow
      return "#" + ((1 << 24) + (parseInt(r) << 16) + (parseInt(g) << 8) + parseInt(b)).toString(16).slice(1);
    }

    //function for basic lines
    function drawline(x1,y1,x2,y2,color,width){
      width=width||1;
      ctx.beginPath();
      ctx.strokeStyle=color;
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.lineWidth = width;
      ctx.stroke();
    }

    //function for basic circle
    function circle(cx,cy,cr,color){
      ctx.beginPath();
      ctx.strokeStyle=color;
      ctx.fillStyle = color;
      ctx.arc(cx, cy, cr, 0, 2 * Math.PI);
      ctx.stroke();
      ctx.fill();
    }

    function drawcity(cx,cy,cr,col1,col2){
      ctx.beginPath();
      ctx.strokeStyle=col1;
      ctx.fillStyle=col2;
      ctx.arc(cx, cy, cr, 0, 2 * Math.PI);
      ctx.stroke();
      ctx.fill();
    }

    function tlx(xv){ return (xv*squarescaler)+midwidth; }
    function tly(yv){ return (yv*squarescaler)+midheight; }

    function pausefunction(){
      paused=!paused;
    }

    function keypressed(keyevt){
      if (keyevt.keyCode==32) pausefunction();
    }

    function initstuff(){
      mcanvas = document.getElementById("mcanvas");
      ctx = mcanvas.getContext('2d');

      infodiv_drag=document.getElementById('details');
      infodiv=document.getElementById('details_main');
      infodiv_info=document.getElementById('maininfoarea');
      infodiv_infopersonal=document.getElementById('maininfoareapersonal');
      infotooltip=document.getElementById('slidertooltip');
      infodiv.style.width='min-content';
      dragstatuswindow(infodiv_drag);
      setupcities();
      disease=createdisease();
      diseases.push(disease);

      document.addEventListener('keydown', function(evt){keypressed(evt)}, false);
      mcanvas.addEventListener('mousedown', function(evt) {
        followperson();
      }, false);
      mcanvas.addEventListener('mousemove', function(evt) {
        mousePos = getMousePos(mcanvas, evt);
      }, false);

      infodiv.onmouseover=function(){
        infodiv_info.style.display="block";
        //infodiv.style.width='33%';
      }
      infodiv.onmouseleave=function(){
        infodiv_info.style.display="none";
        //infodiv.style.width='max-content';
      }
      animate();
      infodiv_info.innerHTML+="<br/>City generation...";
    }

    function animate(){
      if (!paused) timer+=1;
      set_height_width_vars();
      reset_background();
      if (cityarranging){ normalizecityforces(); actuponcityforces();}      
      if (peoplearranging && (peoplegenerated==false)) {populate();}
      if (peoplegenerated && !controlpanelcreated) {controlpaneldiv();controlpanelcreated=true}      
      drawcities();
      if (!paused) {movepeople(peopleA,statA);movepeople(peopleB,statB);}
      drawpeople();
      dofollowdetails();
      if (!paused) {
        if ((timer % 10==0)&&(initinfection)&&(initinfectcount<5)) {startinfections();}
        progressinfections(peopleA,statA);
        progressinfections(peopleB,statB);
        vaccinateandboost(peopleA);//not B! A only, B is the crazy folks!
      }
      requestAnimFrame(animate);
      if (dovaccinations) document.getElementById("vstart").disabled=true;
    }


    function reset_background(){
      ctx.fillStyle=rgbToHex(10,30,30);
      ctx.fillRect(0,0,maxwidth,maxheight);//background rectangle
      ctx.fillStyle=rgbToHex(200,230,230);
      ctx.fillRect(midwidth-squarescaler,midheight-squarescaler,squarescaler*2,squarescaler-1);//center rect
      ctx.fillStyle=rgbToHex(230,230,200);
      ctx.fillRect(midwidth-squarescaler,midheight,squarescaler*2,squarescaler);//center rect
    }

    function drawcities(){
      for (let cidx = 0; cidx < cities.length; cidx++) {
        drawcity( tlx(cities[cidx].x),
                  tly(cities[cidx].y-0.5),
                  cities[cidx].r*squarescaler,
                  cities[cidx].col1,cities[cidx].col2);
        drawcity( tlx(cities[cidx].x),
                  tly(cities[cidx].y+0.5),
                  cities[cidx].r*squarescaler,
                  cities[cidx].col1,cities[cidx].col2);
        if (cidx<cities.length-1){
          ctx.fillStyle=rgbToHex(240,220,220);
          ctx.textAlign = "center";
          Hsize=cities[cidx].r*squarescaler/10;
          ctx.font = Hsize+"em Consolas";
          ctx.fillText(cidx, tlx(cities[cidx].x), tly(cities[cidx].r/2.5+cities[cidx].y-0.5));
          ctx.fillText(cidx, tlx(cities[cidx].x), tly(cities[cidx].r/2.5+cities[cidx].y+0.5));
        }
      }
      ctx.fillStyle=rgbToHex(240,220,220);
      ctx.textAlign = "center";
      Hsize=squarescaler/70;
      ctx.font = Hsize+"em Consolas";
      ctx.fillText("H", tlx(cities[maxcities-1].x), tly(cities[maxcities-1].y-0.445));
      ctx.fillText("H", tlx(cities[maxcities-1].x), tly(cities[maxcities-1].y+0.555));
    }

    function followperson(){
      followingperson=Object.assign({},personundermouse);
    }

    lgray=rgbToHex(90,90,90)
    function dofollowdetails(){
      persondetails="";
      if (followingperson.ab==-1) {
        document.getElementById("maininfoareapersonal").innerHTML="Not following anyone";
        return;
      }
      if (followingperson.ab==0) worldsafe="This world follows precautions";
      if (followingperson.ab==1) worldsafe="This world ignores precautions";
      pidx=followingperson.n
      if (followingperson.ab==0) person=peopleA[pidx]
      if (followingperson.ab==1) person=peopleB[pidx]
      personorigin=person.scity;
      persontravelinfo="";
      personvisitinfo="";
      persongoingto=person.stcity;
      if (persongoingto==maxcities-1) persongoingto="Hospital";
      if (person.stcity >=0) {
        persontravelinfo=("P-"+pidx)+" is "+ ((person.stprogress*100).toFixed())+"% way to "+persongoingto;
        personvisitinfo=" - "+((person.stduration-timer)/daymultiplier).toFixed(2)+" time left";
        if (person.sreturning){
          persontravelinfo=("P-"+pidx)+" is "+ ((person.stprogress*100).toFixed())+"% way from "+persongoingto;
          personvisitinfo="";
        }
      } else {
        persontravelinfo=("P-"+pidx)+ " is not travelling";
      }
      sicklevel=person.phase[0];
      if (!person.salive) {
        document.getElementById("maininfoareapersonal").innerHTML="Not following anyone";
        followingperson={"n":-1,"ab":-1};
        return;
      }
      if (sicklevel==0) sickstate="Healthy";
      phasetime=0;
      if (sicklevel==1) {sickstate="Getting sick";phasetime=person.ssick_timetillcontagious}
      if (sicklevel==2) {sickstate="Sick";phasetime=person.ssick_timetillbad}
      if (sicklevel==3) {sickstate="Dying";phasetime=person.ssick_timetilldead}
      if (sicklevel==4) {sickstate="Serious but won't die";phasetime=person.ssick_timebad2sick}
      if (sicklevel==5) {sickstate="Getting over it";phasetime=person.ssick_timetillwell}
      nextsickstate="";
      if (person.phase.length>1) {
        pnextphase=person.phase[1]
        if (pnextphase==0) nextsickstate=", getting healthy";
        if (pnextphase==1) nextsickstate=", getting sick";
        if (pnextphase==2) nextsickstate=", will be contagious";
        if (pnextphase==3) nextsickstate=", will perish";
        if (pnextphase==4) nextsickstate=", will be serious";
        if (sicklevel==5) nextsickstate=", will be OK";
      }
      if (sicklevel==3) nextsickstate=" needs medical help"
      phasetimephrase="";
      if (phasetime>0){
        phasetimephrase=" ("+phasetime.toFixed(2)+")";
      }
      sickstate+=nextsickstate+phasetimephrase;

      pdetail=worldsafe+"<br/>"+persontravelinfo+" "+personvisitinfo;
      pdetail=pdetail+"<br/>"+sickstate;
      pdetail=pdetail+"<br/>Resistance level - "+person.resist.toFixed(3);
      maskinfo="Will not wear a mask in this world";
      if (followingperson.ab==0) {
        maskinfo="Will not wear masks"
        if (person.maskchance < masklikeliness) maskinfo="Will wear a mask if required";
      }
      pdetail=pdetail+"<br/>"+maskinfo;
      document.getElementById("maininfoareapersonal").innerHTML=pdetail;
      //linehere
      px=person.sx;
      py=person.sy;
      if (followingperson.ab>=0) {
        if (followingperson.ab==0) ofst=+0.5;
        if (followingperson.ab==1) ofst=-0.5;
        drawline(tlx(-1),tly(py-ofst),tlx(+1),tly(py-ofst),lgray,1);
        drawline(tlx(px),tly(0),tlx(px),tly(-ofst*2),lgray,1);
      }
    }

    var pcol1=rgbToHex(10,10,10);
    var pcol1t=rgbToHex(0,180,0);
    var pcol2=rgbToHex(80,80,80);
    var pcol2_inf=rgbToHex(240,220,200);
    var pcol2_sik=rgbToHex(245,120,100);
    var pcol2_wel=rgbToHex(245,120,200);
    var pcol2_bad=rgbToHex(255,0,0);
    var pcol2_HL=rgbToHex(255,255,255);
    function drawperson(px,py,travelling,sickphase,other){
      ctx.beginPath();
      ctx.lineWidth=2;
      ctx.strokeStyle=pcol1;
      //if (travelling>0) ctx.strokeStyle=pcol1t;
      pcolor=pcol2;
      if (sickphase==1) pcolor=pcol2_inf;
      if (sickphase==2 || sickphase==4 || sickphase==5) pcolor=pcol2_sik;
      if (sickphase==3) pcolor=pcol2_bad;
      if (dist(px,py,mousePos.x,mousePos.y)<squarescaler/90) pcolor=pcol2_HL;
      ctx.fillStyle=pcolor;
      ctx.arc(px, py, squarescaler/150, 0, 2 * Math.PI);
      ctx.stroke();
      ctx.fill();
      ctx.fillStyle=rgbToHex(0,0,0);  //useful over head debug text thing
      ctx.textAlign = "center";
      Hsize=squarescaler/500;
      ctx.font = Hsize+"em Consolas";
      ctx.fillText(other, px, py-squarescaler/70);
      if (dist(px,py,mousePos.x,mousePos.y)<squarescaler/90) return true;
    }

    function drawpeople(){
      personundermouse={"n":-1,"ab":-1};
      for (let pidx = 0; pidx < peopleA.length; pidx++){
        stpx=tlx(peopleA[pidx].sx);
        stpy=tly(peopleA[pidx].sy);
        utpx=tlx(peopleB[pidx].sx);
        utpy=tly(peopleB[pidx].sy);
        puma=false;
        pumb=false;
        if (peopleA[pidx].salive) puma=drawperson(stpx,stpy-squarescaler/2,peopleA[pidx].stprogress,peopleA[pidx].phase[0],"");
        if (peopleB[pidx].salive) pumb=drawperson(utpx,utpy+squarescaler/2,peopleB[pidx].stprogress,peopleB[pidx].phase[0],"");
        if (puma) personundermouse={"n":pidx,"ab":0}
        if (pumb) personundermouse={"n":pidx,"ab":1}
      }
      ctx.fillStyle=rgbToHex(0,0,0);
      ctx.textAlign = "center";
      Hsize=squarescaler/300;
      ctx.font = Hsize+"em Consolas";
      offset=0.01;
      if (peoplegenerated){
        ctx.fillText("Alive "+statA.alive, tlx(-0.8), tly(-0.03+offset));
        ctx.fillText("Alive "+statB.alive, tlx(-0.8), tly(+0.03+offset));
        ctx.fillText("Sick "+statA.infected, tlx(-0.4), tly(-0.03+offset));
        ctx.fillText("Sick "+statB.infected, tlx(-0.4), tly(+0.03+offset));
        ctx.fillText("Hospitalized "+statA.checkin, tlx(0), tly(-0.03+offset));
        ctx.fillText("Hospitalized "+statB.checkin, tlx(0), tly(+0.03+offset));
        ctx.fillText("Passed "+statA.dead, tlx(0.4), tly(-0.03+offset));
        ctx.fillText("Passed "+statB.dead, tlx(0.4), tly(+0.03+offset));
      }
    }


    function calc_personxy(city,offset,rvelocity,radius1, radius2, radialoffset, timingoffset){
      cityx=cities[city].x;
      cityy=cities[city].y;
      gobetween=Math.pow(Math.sin(offset*rvelocity),2);
      sr=radius1*gobetween+(1-(gobetween))*radius2;
      p_ox=Math.sin(radialoffset+timingoffset*cities[city].r)*cities[city].r*0.95*sr;
      p_oy=Math.cos(radialoffset+timingoffset*cities[city].r)*cities[city].r*0.95*sr;
      x=cityx+p_ox;
      y=cityy+p_oy;
      return ({"x":x,"y":y});
    }

    function movepeople(people,stat){
      stat.checkin=0;

      for (let pidx = 0; pidx < people.length; pidx++){
        if (people[pidx].salive){
          person=people[pidx];
          person.soffset+=0.01*person.direction;
          sxy=calc_personxy(person.scity, person.soffset, person.srv, person.sr, person.sr2, person.sradoffset, person.soffset);
          person.sx=sxy.x;
          person.sy=sxy.y;
          if (person.stcity>-1) {
            if (person.stprogress>=1 && person.stcity==maxcities-1){//if person is AT hospital
              stat.checkin+=1;
            }
            if ((person.stprogress<1)&&(person.stduration>timer)&&(person.stcity<maxcities-1)){
              person.stprogress+=0.005;
            }
            if ((person.stprogress<1)&&(person.stduration>timer)&&(person.hospitalized)&&person.stcity==maxcities-1){
              if (stat.checkin<Hospitalmax) person.stprogress+=0.005;
            }
            if ((person.stprogress>0)&&person.stcity==maxcities-1){
              if (stat.checkin>Hospitalmax) { //need to turn away person
                if (person.sdisease>=0){
                  person.stduration=timer-1;
                  person.sreturning=true;
                  person.hospitalized=false;
                  disease=diseases[person.sdisease]
                  person.timetohospital=disease.gethelp_min+Math.random()*(disease.gethelp_max-disease.gethelp_min);                
                  person.timeinhospital=0;
                } else { //person got well on the way to hospital
                  person.stduration=timer-1;
                  person.sreturning=true;
                  person.hospitalized=false;
                }
              } else {
                if (person.stprogress>=1) person.timeinhospital+=1;

              }
            }
            if ((person.stprogress>0)&&(person.stduration<timer)){
              person.stprogress-=0.005;
              person.sreturning=true;
            }
            if ((person.stprogress>0)&&(person.stduration<timer)&&(person.hospitalized)&&(person.stcity<maxcities-1)){
              person.stduration=timer;
            }
            stxy=calc_personxy(person.stcity, person.soffset, person.srv, person.sr, person.sr2, person.sradoffset, person.soffset);
            person.sx=sxy.x*(1-person.stprogress)+stxy.x*person.stprogress;
            person.sy=sxy.y*(1-person.stprogress)+stxy.y*person.stprogress;
            if ((person.stprogress<=0)&&(person.sreturning)) { //return logic
              if (person.stcity == maxcities-1 && person.sdisease>=0) {
                disease=diseases[person.sdisease];
                person.timetohospital=disease.gethelp_min+Math.random()*(disease.gethelp_max-disease.gethelp_min);
                person.timeinhospital=0;
              }
              person.stprogress=0;
              person.sreturning=false;
              person.stcity=-1;
            }
          }

          if (person.stcity==-1 && person.hospitalized && person.stprogress<=0){
            person.stcity=maxcities-1;
            duration=timer+Math.random()*2000+220;
            person.stduration=duration;
          }

          cantravel=true;
          if (dotravelrestriction && person.travelanyway<travelrestrictiveness) cantravel=false;
          if (person.travelchance > Math.random()*2000 && cantravel && person.stcity==-1){
            traveltocity=Math.floor(Math.random()*(maxcities-1));
            duration=timer+Math.random()*2000+220;
            if (traveltocity !== person.scity){
              person.stcity=traveltocity;
              person.stprogress=0;
              person.stduration=duration;
            }
          }
        }
      }
    }

    function createdisease(){
      disease={}
      disease.variant=0;
      disease.killrate=0.15;
      disease.killrate_withcare=0.075;
      disease.killrate_vaccinated=0.05;
      disease.killrate_vaccinatedwithcare=0.005;
      disease.badrate=0.30;
      disease.badrate_vaccinated=0.05;
      disease.timetillcontagious_min=1;//assume days, can be multiplied internally to make more sense later
      disease.timetillcontagious_max=3;
      disease.timetillbad_min=5; //Person can be destined for
      disease.timetillbad_max=20; //mild case, bad case (needs hospital)
      disease.timetillwell_min=15; //deadly case, will kill, lower chance in hospital
      disease.timetillwell_max=40;      
      disease.timetilldeath_min=5;
      disease.timetilldeath_max=40;
      disease.timebad2sick_min=disease.timetillwell_min;
      disease.timebad2sick_max=disease.timetillwell_max;
      disease.gethelp_min=2;
      disease.gethelp_max=20;
      disease.contagious_threshold=0.25; // should be this sick to be contagious
      disease.spreadability=(1/60)*0.1; //10% chance per second
      disease.maskblockrate=0.05; //chance of mask to prevent entry of disease to person
      disease.maskcontainrate=0.8; //chance of mask to prevent spreading of disease from person
      disease.vaccineeffectiveness=0.90;
      disease.postresistance=0.7;
      return disease;
    }

    function inbetween(a,b,v){
      return (1-v)*a+v*b;
    }

    function infectperson(pn,dn,peoplearray,stat){
      /*
      Phases
      1:well->sick
      2:sick->bad
      3:bad->dead
      4:bad->sick
      5:sick->well
      */     
      person=peoplearray[pn];
      if ((person.salive)&&(person.sdisease<0)) {
        infect=true;
        if (person.maskchance<masklikeliness && domasks) {
          if (Math.random()<disease.maskblockrate) infect=false;
        }
        if (!infect) return;


        resistancetimefactor=Math.pow(1-person.resist,0.3);//resistance will decrease time sick
        //power of 0.3 gets us roughly 80% sick time at 50% resistance
        disease=diseases[dn];
        stat.infected+=1;
        person.sdisease=dn;
        person.carecheck=false;
        person.ssick_timetillcontagious=disease.timetillcontagious_min+Math.random()*(disease.timetillcontagious_max-disease.timetillcontagious_min);
        person.ssick_timetillbad=disease.timetillbad_min+Math.random()*(disease.timetillbad_max-disease.timetillbad_min);
        person.ssick_timetillwell=disease.timetillwell_min+Math.random()*(disease.timetillwell_max-disease.timetillwell_min);
        person.ssick_timetilldead=disease.timetilldeath_min+Math.random()*(disease.timetilldeath_max-disease.timetilldeath_min);
        person.ssick_timebad2sick=disease.timebad2sick_min+Math.random()*(disease.timebad2sick_max-disease.timebad2sick_min);
        person.timetohospital=disease.gethelp_min+Math.random()*(disease.gethelp_max-disease.gethelp_min);
        person.ssick_timetillwell=person.ssick_timetillwell*resistancetimefactor;
        person.ssick_timebad2sick=person.ssick_timebad2sick*resistancetimefactor;

        chancebad=false;
        chancedeath=false;
        chancedeath=Math.random()<inbetween(disease.killrate,disease.killrate_vaccinated,person.resist);
        chancebad=chancedeath||Math.random()<inbetween(disease.badrate,disease.badrate_vaccinated,person.resist);; // if death, then must get bad        

        person.phase=[1] //getting sick
        if (chancebad) person.phase=person.phase.concat(2) //getting bad
        if (chancedeath) person.phase=person.phase.concat(3) //dying
        if (chancebad) person.phase=person.phase.concat(4) //bad to OK
        person.phase=person.phase.concat(5) //ok to well

      }
    }

    function masktoggle(){
      if (domasks) {
        domasks=false;
        document.getElementById("mstart").innerHTML="Masks";
      } else {
        domasks=true;
        document.getElementById("mstart").innerHTML="UnMask";
      }
    }

    function vaccinateandboost(people){
      if (dovaccinations==false) return

      for (let pidx = 0; pidx < people.length; pidx++){
        person=people[pidx];
        if (person.vaccinehesitancy>vaccinelikeliness) continue;
        person.vaccinedelay-=1/daymultiplier;
        if (person.vaccinedelay<=0) {
          person.resist=diseases[0].vaccineeffectiveness;
          person.vaccinedelay=vaccineavgdelay*falsegamma(midptstretch,curvetune); //time till next vaccine - a booster
          //console.log("P"+pidx+" was vaccinated/boostered");
          person.resistdecay=0.9999; //decay curve for vaccination is not as steep as post disease resistance
        }
      }
    }
    function progressinfections(people,stat){
      /*
      Phases
      1:well->sick
      2:sick->bad
      3:bad->dead <-- do goto hospital here
      4:bad->sick
      5:sick->well <-- can return from hospital here
      6:at hospital
      */
      for (let pidx = 0; pidx < people.length; pidx++){
        person=people[pidx];
        person.resist=person.resist*person.resistdecay;//resistance decreases over time
        if ((person.sdisease>=0)&&(person.salive)&&(person.phase.length>0)){
          if (person.phase[0]==1) person.ssick_timetillcontagious-=1/daymultiplier;
          if (person.phase[0]==2) person.ssick_timetillbad-=1/daymultiplier;
          if (person.phase[0]==3) person.ssick_timetilldead-=1/daymultiplier;
          if (person.phase[0]==3 || person.phase[0]==4) person.timetohospital-=1/daymultiplier;
          if (person.phase[0]==4) person.ssick_timebad2sick-=1/daymultiplier;
          if (person.phase[0]==5) person.ssick_timetillwell-=1/daymultiplier;

          if (person.phase[0]==1 && person.ssick_timetillcontagious<=0) {
            person.phase=person.phase.slice(1)
          }
          if (person.phase[0]==2 && person.ssick_timetillbad<=0) {
            person.phase=person.phase.slice(1)
          }
          if (person.phase[0]==3 && person.ssick_timetilldead<=0) {
            person.salive=false;
            stat.infected-=1;
            if (person.hospitalized) stat.hospitalized-=1;
            stat.dead+=1;
            stat.alive-=1;
            person.stcity=-1;
            person.stprogress=0;
          }

          if ((person.phase[0]==3 || person.phase[0]==4) && person.timetohospital<=0 && !person.hospitalized && stat.checkin<Hospitalmax) {
            stat.hospitalized+=1;
            person.hospitalized=true;
          }
          if (person.phase[0]==3 && person.hospitalized && person.stcity==maxcities-1 && person.stprogress>=1 && person.carecheck==false && person.timeinhospital>=100) {
            /*if person would die without help
            chance of death is k, chance with care is c
            as everyone in this conditional suceeded k, chance death now is c/k 
            e.g. 
            if 50% of people die normally, but only 10% die with care
            then OF those who will die, 80% survive with care
            recomputing chance of death for those that will die, it's 10/50
            */
            person.carecheck=true;
            disease=diseases[person.sdisease];
            if (!person.svac) {
              chancedeathnovac=(disease.killrate_withcare/disease.killrate)
              chancedeathvac=(disease.killrate_vaccinatedwithcare/disease.killrate_vaccinated)
              chancedeath=inbetween(chancedeathnovac,chancedeathvac,person.resist)
              if (chancedeath<Math.random()){
                //don't die, add time for phase 3 to phase 4 and remove phase 3
                person.ssick_timebad2sick+=person.ssick_timetilldead;
                person.phase=person.phase.slice(1);
              }
            }
          }

          if (person.phase[0]==4 && person.ssick_timebad2sick<=0) {
            person.phase=person.phase.slice(1);
          }
          if (person.phase[0]==5 && person.ssick_timetillwell<=0) {
            person.phase=[0]
            person.resist=(diseases[person.sdisease].postresistance)*(Math.pow(Math.random()*2,0.1)/2);
            /* so wth does this do? - (Math.pow(Math.random()*2,0.1)/2)
            ok, so we can't assume that everyone will come off the disease with equal resistance
            This gives us a small chance of crappy resistance, and good chance of normal resistance.
            */
            person.sdisease=-1;//not sick anymore
            stat.infected-=1;
            person.ssick_timetilldead=-1;
            person.ssick_timetillbad=-1;
            person.ssick_timetillcontagious=-1;
            person.ssick_timetillwell=-1;
            person.timetohospital=-1;
            if (person.hospitalized) {
              person.hospitalized=false;
            }
            person.carecheck=false;
            person.vaccinedelay=vaccineavgdelay*falsegamma(midptstretch,curvetune);
          }

          //do infect others
          spreadradius=0.001;
          if (person.phase[0]>=2){// if infectious!
            disease=diseases[person.sdisease]
            for (let pidx2 = 0; pidx2 < people.length; pidx2++){
              if (people[pidx2].salive){ //dont bother unless other is alive 
                if (people[pidx2].sdisease<0){ //and not already infected
                  if (disease.spreadability>Math.random() && // check against disease spreadability
                      people[pidx2].resist<Math.pow(Math.random(),4)){ // check against person resistance, power function distributes more low values.
                    d=Math.pow(person.sx-people[pidx2].sx,2)+Math.pow(person.sy-people[pidx2].sy,2);
                    if (d<spreadradius) {
                      if ((person.stcity==maxcities-1)&&(person.stprogress==1)) { //you're not in the hospital
                        if (Hospitaltransmissionreduction>Math.random()) {
                          infect=true;
                          if (domasks && person.maskchance<masklikeliness) {
                            if (Math.random()<disease.maskcontainrate) infect=false;
                          }
                          if (infect) infectperson(pidx2,person.sdisease,people,stat);
                        }
                      } else { //apply hospital reduction since person is in hospital quarantine
                        infect=true;
                        if (domasks && person.maskchance<masklikeliness) {
                          if (Math.random()<disease.maskcontainrate) infect=false;
                        }
                        if (infect) infectperson(pidx2,person.sdisease,people,stat);
                      }
                    } 
                  }
                }
              }
            }
          }//do infect others

        }
      }
    }

    function startinfections(){
      luckyperson=Math.floor(Math.random()*peopleA.length);      
      if (peopleA[luckyperson].stprogress>0.1){
        infectperson(luckyperson,0,peopleA,statA);
        infectperson(luckyperson,0,peopleB,statB);
        initinfectcount+=1;
      }
      document.getElementById("istart").disabled=true;
    }


    function setupcities(){
      phase=0;
      cityarranging=true;
      cities=[];
      peopleA=[];
      peopleB=[];
      diseases=[];
      domasks=false;
      dovaccinations=false;
      peoplearranging=false;
      peoplegenerated=false;
      initinfection=false;
      paused=false;
      timer=0;
      maxcities=3+Math.floor(Math.random()*8);
      //maxcities=8;
      citycount=3+Math.floor(Math.random()*(maxcities-2));
      for (let cidx = 0; cidx < maxcities; cidx++) {
        city={};
        city.x=-0.5+Math.random(); //-0.5 to 0.5
        city.y=-0.25+Math.random()*0.5; //-0.25 to 0.25
        city.r=0.075+0.15*Math.pow((1+cidx)/maxcities,3);
        city.dx=0;
        city.dy=0;
        city.ishospital=false;
        city.col1=rgbToHex(50+50*Math.random(),50+50*Math.random(),0);
        city.col2=rgbToHex(150+50*Math.random(),150+50*Math.random(),150+50*Math.random());
        cities.push(city);
      }
      city={};
      city.x=-0.5+Math.random();
      city.y=-0.25+Math.random()*0.5;
      city.r=0.075+0.15*Math.pow(0.5,3);
      city.dx=0;
      city.dy=0;
      city.ishospital=true;
      city.col1=rgbToHex(250,25+50*Math.random(),25+50*Math.random());
      city.col2=rgbToHex(200+50*Math.random(),100+50*Math.random(),100+50*Math.random());
      cities.push(city);
      maxcities+=1;
    }

    function dist(x1,y1,x2,y2){
	    return Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,2));
    }

    function normalizecityforces(){
      peoplearranging=false;
      cityincity=false;
      for (let cidx1 = 0; cidx1 < maxcities; cidx1++) {
        cities[cidx1].dx=0;
        cities[cidx1].dy=0;
        for (let cidx2 = 0; cidx2 < maxcities; cidx2++) {
          if (cidx2 !== cidx1) {
            citydistance=dist(  cities[cidx1].x,cities[cidx1].y,
                                cities[cidx2].x,cities[cidx2].y);
            if (citydistance-(cities[cidx1].r+cities[cidx2].r) <= 0) cityincity=true;
            citydistance=Math.max(citydistance-(cities[cidx1].r+cities[cidx2].r),0.000000001);
            forcemultiplier=1/Math.pow(citydistance,2);
            cities[cidx1].dx+=(cities[cidx1].x-cities[cidx2].x)*forcemultiplier;
            cities[cidx1].dy+=(cities[cidx1].y-cities[cidx2].y)*forcemultiplier;
          }
        }
        distfromedge_lef=Math.max(+1.0+(cities[cidx1].x-cities[cidx1].r),0.0000001);
        distfromedge_rig=Math.max(+1.0-(cities[cidx1].x+cities[cidx1].r),0.0000001);
        distfromedge_top=Math.max(+0.5+(cities[cidx1].y-cities[cidx1].r),0.0000001);
        distfromedge_bot=Math.max(+0.5-(cities[cidx1].y+cities[cidx1].r),0.0000001);
        cities[cidx1].dx+=1.5/Math.pow(distfromedge_lef,2);//force from left edge
        cities[cidx1].dx-=1.5/Math.pow(distfromedge_rig,2);//force from right edge
        cities[cidx1].dy+=1.5/Math.pow(distfromedge_top,2);//force from left edge
        cities[cidx1].dy-=1.5/Math.pow(distfromedge_bot,2);//force from right edge
      }
    }

    function actuponcityforces(){
      var maxmag=0;
      for (let cidx = 0; cidx < maxcities; cidx++) {
        maxmag=Math.max(dist(0,0,cities[cidx].dx,cities[cidx].dy),maxmag);
      }
      var slowdown=100;
      if (cityincity) slowdown=20;
      movementrate=0
      for (let cidx = 0; cidx < maxcities; cidx++) {
        forcemag=dist(0,0,cities[cidx].dx,cities[cidx].dy);
        if (forcemag>0.01){
          cities[cidx].dx=cities[cidx].dx/(maxmag);
          cities[cidx].dy=cities[cidx].dy/(maxmag);
        }
        cities[cidx].l2x=cities[cidx].lx;
        cities[cidx].l2y=cities[cidx].ly;
        cities[cidx].lx=cities[cidx].x;
        cities[cidx].ly=cities[cidx].y;
        cities[cidx].x=cities[cidx].x+cities[cidx].dx/slowdown;
        cities[cidx].y=cities[cidx].y+cities[cidx].dy/slowdown;
        if ((cities[cidx].x+cities[cidx].r)>1) cities[cidx].x=1-cities[cidx].r;
        if ((cities[cidx].y+cities[cidx].r)>0.5) cities[cidx].y=0.5-cities[cidx].r;
        if ((cities[cidx].x-cities[cidx].r)<-1) cities[cidx].x=-1+cities[cidx].r;
        if ((cities[cidx].y-cities[cidx].r)<-0.5) cities[cidx].y=-0.5+cities[cidx].r;
        cities[cidx].movementrate=dist(cities[cidx].x,cities[cidx].y,cities[cidx].l2x,cities[cidx].l2y);
        if (cities[cidx].movementrate > movementrate) movementrate=cities[cidx].movementrate;
      }      
      if (maxmag<10000) {
        if (movementrate<0.001) {
          cityarranging=false;
          phase=1;
          peoplearranging=true;
        }
      }
    }

    function falsegamma(stretchgraph,curvesquash){
      //vaccine delay for a person should follow a bell curve
      //to simulate the bell curve, we can use tan
      //you can't take the vaccine earlier than 0 days, and you can delay perpetually.
      //if we take a random value from 0 to pi/2, tan returns 0 to infinity
      //that's great, but the curve sucks, need more bell.
      //raising tan(x) to a fractional power, concentrates the curve about 1
      //to ensure a response limit and maximum delay
      //we can stretch the curve from 0 to pi/2 in the xaxis,
      //then shift it slightly to adjust values for x=0 through x=1
      vx=Math.random(); // 0<vx<1;
      midptstretch=0.001;//used to stretch the curve to get definite min/max values instead of 0 and inf
      if (stretchgraph) midptstretch=stretchgraph;
      curvetune=0.1; //lower numbers cluster distribution about the average
      if (curvesquash) curvetune=curvesquash;
      tancurve=Math.tan(((vx+midptstretch)*Math.PI/2)/(1+midptstretch*2));
      return Math.pow(tancurve,curvetune);      
    }

    function populate(){
      infodiv_info.innerHTML+="<br/>Populating...";
      peopleA=[];
      peopleB=[];
      statA.alive=0;
      statA.dead=0;
      statA.infected=0;
      statA.vaccinated=0;
      statA.hospitalized=0;
      statA.checkin=0;
      statB=Object.assign({},statA);
      dovaccinations=false;
      initinfection=false;
      peoplegenerated=false;
      peoplearranging=false;
      initinfectcount=0;

      for (let cidx = 0; cidx < maxcities-1; cidx++) {
        popcount=Math.pow(cities[cidx].r,2)*2000;
        popcount=popcount*(Math.random()*0.5+0.5);//limit density randomly
        for (let pidx = 0; pidx < popcount; pidx++) {          
          person={};
          citypick=cidx;
          person.scity=citypick;
          person.ucity=citypick;

          person.age=Math.random()*Math.random()*110;//age may affect fatality
          person.direction=Math.random()*2-1;//Person moves in a particular direction
          person.travelchance=Math.pow(Math.random(),2)//non uniform chance to travel

          person.soffset=Math.random()*Math.PI*2;//movement is modelled on trig, this is offset for up to a full period          
          person.sfollowslockdown=Math.random(); //how strictly person follows safety procedures
          person.sx=0;//safe x
          person.sy=0;
          person.sr=Math.sqrt(Math.random());//keeps people out of somewhat clustered center
          person.sr2=Math.sqrt(Math.random());//person moves between a couple radius in daily movement
          person.srv=Math.sqrt(Math.random());//how fast they move
          person.sradoffset=Math.random()*Math.PI*2;
          person.salive=true;
          person.stcity=-1; //safe travel to city
          person.stduration=-1; // trip duration
          person.stprogress=0; // trip progression
          person.sdisease=-1;
          person.ssick_timetillcontagious=-1;
          person.ssick_timetillbad=-1;
          person.ssick_timebad2sick=-1;
          person.ssick_timetillwell=-1;
          person.ssick_timetilldead=-1;
          person.timetohospital=-1;
          person.timeinhospital=0;
          person.hospitalized=false;
          person.carecheck=false; //checked if hospital will save them
          person.svac=false;
          person.resist=0;
          person.resistdecay=0.999;          
          person.vaccinehesitancy=Math.random(); //decide if a person will get vaccinated
          person.maskchance=Math.random(); //inverted, 0 is always, 1 is never
          person.travelanyway=Math.random();
          person.vaccinedelay=vaccineavgdelay*falsegamma(midptstretch,curvetune);
          person.phase=[0];
          peopleA.push(Object.assign({},person));
          statA.alive+=1;
          person.maskchance=1;//b people don't mask up
          person.vaccinehesitancy=1;// b people don't get vaccinated
          person.travelanyway=1; // b doesn't care, will travel. 
          peopleB.push(Object.assign({},person));
          statB.alive+=1;
        }
      }
      phase+=1;
      peoplegenerated=true;
      peoplearranging=false;
    }

    function set_height_width_vars(){
      //get canvas width and height
      ctx.canvas.width  = window.innerWidth;
      ctx.canvas.height = window.innerHeight*1;
      //keep useful variables
      //maximum canvas height, width
      maxwidth=mcanvas.width;
      maxheight=mcanvas.height;
      //middle canvas height, width
      midwidth=mcanvas.width/2;
      midheight=mcanvas.height/2;
      //represents the half the length of a side of the biggest
      //square that fits a rectangular screen
      squarescaler=Math.min(midwidth,midheight);
    }

    function paint(cnvname){
      initstuff();
    }

    window.requestAnimFrame = (function(callback) {
      return  window.requestAnimationFrame ||
              window.webkitRequestAnimationFrame ||
              window.mozRequestAnimationFrame ||
              window.oRequestAnimationFrame ||
              window.msRequestAnimationFrame ||
              function(callback) {
                window.setTimeout(callback, 1000 / 60);
              };
    })();
    

    function slider(text,id, min, max, step){
      divid=id+"_div"
      line="<div class=\"cfgent\" id=\""+divid+"\" name=\""+divid+"\">"+text+" : <span class=\"slideval\" id=\""+id+"_v\"></span><input type=\"range\" min=\""+min+"\" max=\""+max+"\" step=\""+step+"\" name=\""+id+"\" id=\""+id+"\" class=\"slider\"></div>";
      return line;
    }

    function slideinit(name,value,onchangefunc){
      document.getElementById(name).value=value;
      document.getElementById(name+"_v").innerHTML=document.getElementById(name).value;
      document.getElementById(name).onmousemove=(function(){
        document.getElementById(name+"_v").innerHTML=document.getElementById(name).value;
      })
      document.getElementById(name).onchange=onchangefunc;
    }


    function tooltip_slide(slideid,text){
      divid=slideid+"_div";
      tooltip(divid,text);
    }

    function tooltip(divid,text){
      divele=document.getElementById(divid);
      divele.onmouseleave=function(){infotooltip.innerHTML="";}
      divele.onmousemove=function(){infotooltip.innerHTML="<br/>------------------------------------------------------<br/>"+text;}
    }

    function controlpaneldiv(){
      //ctrlpanel=document.createElement("div");
      startinfection="<button type=\"button\" name=\"istart\" id=\"istart\" onclick=\"initinfection=true;\">Infect...</button>";
      vaccinebhtml="<button type=\"button\" name=\"vstart\" id=\"vstart\" onclick=\"dovaccinations=true;\">Vaccinate</button>";
      
      maskbhtml="<button type=\"button\" name=\"mstart\" id=\"mstart\" onclick=\"masktoggle()\">Masks</button>";
      
      rate_I=slider("Infection Rate","irate",0,1,0.01);
      rate_B=slider("Serious %","brate",0,1,0.01);
      rate_D=slider("Death %","drate",0,1,0.01);
      rate_Dh=slider("Death %(H)","drateh",0,0.5,0.01);
      rate_Dv=slider("Death %(V)","dratev",0,0.5,0.01);
      rate_Dhv=slider("Death %(H+V)","dratehv",0,0.1,0.001);
      time2skmin_html=slider("Time to sick min","time2skmin",1,100,1);
      time2skmax_html=slider("Time to sick max","time2skmax",1,100,1);
      time2bdmin_html=slider("Time to bad min","time2bdmin",1,100,1);
      time2bdmax_html=slider("Time to bad max","time2bdmax",1,100,1);
      time2ddmin_html=slider("Time to dead min","time2ddmin",1,100,1);
      time2ddmax_html=slider("Time to dead max","time2ddmax",1,100,1);
      time2wlmin_html=slider("Time to well min","time2wlmin",1,100,1);
      time2wlmax_html=slider("Time to well max","time2wlmax",1,100,1);
      time2hcmin_html=slider("Wait for help min","time2hcmin",1,100,1);
      time2hcmax_html=slider("Wait for help max","time2hcmax",1,100,1);
      rate_vac_html=slider("Vaccine acceptance","vrate",0,1,0.01);
      rate_msk_html=slider("Mask acceptance","mrate",0,1,0.01);

      infodiv_info.innerHTML= "<br/>"+startinfection+vaccinebhtml+maskbhtml+"<br/>"+
      rate_I+
      rate_B+
      rate_D+
      rate_Dh+
      rate_Dv+
      rate_Dhv+
      time2skmin_html+
      time2skmax_html+
      time2bdmin_html+
      time2bdmax_html+
      time2ddmin_html+
      time2ddmax_html+
      time2wlmin_html+
      time2wlmax_html+
      time2hcmin_html+
      time2hcmax_html+
      rate_vac_html+
      rate_msk_html+
      "<br/>------------------------------------------------------<br/>";
      controlpanelcreated=true;
      slideinit("irate",diseases[0].spreadability*60,function(){diseases[0].spreadability=document.getElementById("irate").value/60});
      slideinit("brate",diseases[0].badrate,function(){diseases[0].badrate=document.getElementById("brate").value;});
      slideinit("drate",diseases[0].killrate,function(){diseases[0].killrate=document.getElementById("drate").value;});
      slideinit("drateh",diseases[0].killrate_withcare,function(){diseases[0].killrate_withcare=document.getElementById("drateh").value});
      slideinit("dratev",diseases[0].killrate_vaccinated,function(){diseases[0].killrate_vaccinated=document.getElementById("dratev").value});
      slideinit("dratehv",diseases[0].killrate_vaccinatedwithcare,function(){diseases[0].killrate_vaccinatedwithcare=document.getElementById("dratehv").value});
      slideinit("time2skmin",diseases[0].timetillcontagious_min,function(){diseases[0].timetillcontagious_min=document.getElementById("time2skmin").value});
      slideinit("time2skmax",diseases[0].timetillcontagious_max,function(){diseases[0].timetillcontagious_max=document.getElementById("time2skmax").value});
      slideinit("time2bdmin",diseases[0].timetillbad_min,function(){diseases[0].timetillbad_min=document.getElementById("time2bdmin").value});
      slideinit("time2bdmax",diseases[0].timetillbad_max,function(){diseases[0].timetillbad_max=document.getElementById("time2bdmax").value});
      slideinit("time2ddmin",diseases[0].timetilldeath_min,function(){diseases[0].timetilldeath_min=document.getElementById("time2ddmin").value});
      slideinit("time2ddmax",diseases[0].timetilldeath_max,function(){diseases[0].timetilldeath_max=document.getElementById("time2ddmax").value});
      slideinit("time2wlmin",diseases[0].timetillwell_min,function(){diseases[0].timetillwell_min=document.getElementById("time2wlmin").value;diseases[0].timebad2sick_min=document.getElementById("time2wlmin")});
      slideinit("time2wlmax",diseases[0].timetillwell_max,function(){diseases[0].timetillwell_max=document.getElementById("time2wlmax").value;diseases[0].timebad2sick_max=document.getElementById("time2wlmin")});
      slideinit("time2hcmin",diseases[0].gethelp_min,function(){diseases[0].gethelp_min=document.getElementById("time2hcmin").value});
      slideinit("time2hcmax",diseases[0].gethelp_max,function(){diseases[0].gethelp_max=document.getElementById("time2hcmax").value});
      slideinit("vrate",vaccinelikeliness,function(){vaccinelikeliness=document.getElementById("vrate").value});
      slideinit("mrate",masklikeliness,function(){masklikeliness=document.getElementById("mrate").value});
      tooltip_slide("irate","Every frame that an infecter person is near another is a chance to infect. This slider increases the chance of infection.");
      tooltip_slide("brate","Infections can become serious. A bad infection can make a person seek medical attention.");
      tooltip_slide("drate","Infections can prove fatal. This slider is the chance without any healthcare or resistance."+
      "The outcome is decided ahead of time. A fatal infection will always have a serious phase.");
      tooltip_slide("drateh","A known fatal rate with medical care means we can estimate that a given person that needs medical care has a chance to survive. "+
      "e.g. a 50% rate without care and 10% rate with care, means chance of a person that will pass on has a 40%/50% chance to survive once "+
      "they get to the hospital.");
      tooltip_slide("dratev","Vaccinations reduce the rate of dying. This is not an on-off switch. The approximation here is that it offers a resistance. "+
      "having the disease and getting over it also confers resistance. Resistance decays over time. Decay rate from vaccination is lower, and the "+
      "initial resistance is higher. This is just a model, and not intended to accurately represent a specific infectious disease.<br/><br/>"+
      "Assuming chance of an infection's contraction or seriousness is C and the chance with perfect resistance is CR:<br/>"+
      "Calculated chance = C*(1-resist)+CR*resist<br/>"+
      "With no resistance, base chance (C) alone is used. At best, the better chance CR is used.");
      tooltip_slide("dratehv","This rate is used for dying patients with resistance that go to a hospital.");
      tooltip_slide("time2skmin","At the time of infection a person doesn't know it. This is the minimum incubation period. A sick person is not "+
      "contagious at only this point.");
      tooltip_slide("time2skmax","At the time of infection a person doesn't know it. This is the maximum incubation period. A sick person is not "+
      "contagious at only this point.");
      tooltip_slide("time2bdmin","Where it is calculated that a person will have a serious case, this is the minimum time from being sick, to serious.");
      tooltip_slide("time2bdmax","Where it is calculated that a person will have a serious case, this is the maximum time from being sick, to serious.");
      tooltip_slide("time2ddmin","Where it is calculated that a person will have a fatal case, this is the minimum time from being serious.");
      tooltip_slide("time2ddmax","Where it is calculated that a person will have a fatal case, this is the maximum time from being serious.");
      tooltip_slide("time2wlmin","This is the mimimum time from sick/serious phase to being well.");
      tooltip_slide("time2wlmax","This is the maximum time from sick/serious phase to being well.");
      tooltip_slide("time2hcmin","Not everyone goes to a hospital immidiately. There's always hesitation. This is the minimum hesitation.");
      tooltip_slide("time2hcmax","Not everyone goes to a hospital immidiately. There's always hesitation. This is the maximum hesitation.");
      tooltip_slide("vrate","Everyone generated has a uniform random value for their willingness to vaccinate. If it's less that this value, they will take the vaccine.<br/>"+
      "People are hesitant to get the vaccine. There's often an initial rush but then it slows down as people come to terms with it, or slowly change their minds. "+
      "This delay is an approximation using the average vaccination delay(todo:add slider) using "+
      "m=tan(r*pi/2)^0.1 to curve uniform distribution \"r\" (0-1) into \"faked gamma\" distribution \"m\" (0-infinity).");
      tooltip_slide("mrate","Everyone generated has a uniform random value for their willingness to weak masks. If it's less that this value, they will wear masks.");
    }

    //////////////modified from https://www.w3schools.com/howto/howto_js_draggable.asp////////////////
    function dragstatuswindow(elmnt) {    
        elmnt.onmousedown = statusdragMouseDown;
    }
    function statusdragMouseDown(e) {
          e = e || window.event; e.preventDefault();
          statuswindowposX = e.clientX; statuswindowposY = e.clientY;
          document.onmouseup = statuscloseDragElement;
          document.onmousemove = statusDragging;
    }
    function statusDragging(e) {
          e = e || window.event;
          e.preventDefault();
          statusmidx=infodiv.offsetWidth/2;
          statusmidy=infodiv.offsetHeight/2;
          statuswindowposX = e.clientX-statusmidx;
          statuswindowposY = e.clientY-statusmidy;
          top_pos=statuswindowposY;
          top_pos=Math.max(top_pos,0);top_pos=Math.min(top_pos,document.body.offsetHeight-2*statusmidy);
          left_pos=statuswindowposX;
          left_pos=Math.max(left_pos,0);left_pos=Math.min(left_pos,document.body.offsetWidth-2*statusmidx);
          infodiv.style.top = (top_pos) + "px";
          infodiv.style.left = (left_pos) + "px";
    }
    function statuscloseDragElement() {
          document.onmousemove = null;
          infodiv_drag.onmousedown = statusdragMouseDown;
    }

    function getMousePos(canvas, evt) {//specific to canvas
      var rect = canvas.getBoundingClientRect();
      return {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top
      };
    }
  </script>

  <body onload='initstuff()'>
	<div><canvas id="mcanvas"></canvas></div>
  <div id="details_main" style="
        position: absolute;
        top: 0px;left: 0px;
        border-width: 0px;padding: 0.25em;
        background-color: #600000;color:#ffffff;
        font-size: 1em;font-family: 'Courier New', Courier, monospace;
  ">
  <div id="details" style="background-color:#900000;width:max-content;color:#ffffff;float:left;Text-align:center">---------[mouse to open/drag, space to pause]---------</div>
  <div id="maininfoarea" style="width:100%;height:100%;float:right;">
    Starting...
  </div>
  <br/>
  <div id="maininfoareapersonal" style="width:100%;height:100%;float:right;">Click to follow person</div>
  <div id="slidertooltip" style="width:100%;height:100%;float:right;"></div>
  </div>
  </body>
</html>